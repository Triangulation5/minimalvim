if vim.loader then vim.loader.enable() end; vim.g.loaded_netrw = 1; vim.g.loaded_netrwPlugin = 1; vim.g.mapleader = " "; local opt = vim.opt
for k, v in pairs({ number = true, relativenumber = true, numberwidth = 4,
    signcolumn = "yes",
    tabstop = 4, softtabstop = 4, shiftwidth = 4, expandtab = true,
    smartindent = true, breakindent = true,
    list = true, listchars = { tab = "  ", trail = "·", extends = "›", precedes = "‹", nbsp = "␣" }, smartcase = true,
    hlsearch = false, incsearch = true,
    background = "dark", guicursor = "a:block",
    updatetime = 50, timeoutlen = 150,
    scrolloff = 8, sidescrolloff = 8,
    winborder = "solid", clipboard = "unnamedplus",
    completeopt = { "menuone", "noselect" },
    conceallevel = 0, pumheight = 10, pumblend = 15,
    winblend = 20, swapfile = false, shada = "", ruler = false,
    title = true, titlelen = 0,
}) do opt[k] = v end ; opt.fillchars:append({ eob = " ", stl = " ", horiz = " ", horizup = " ", horizdown = " ", vertleft = " ", vertright = " ", verthoriz = " " }); local mini_path = vim.fn.stdpath("data") .. "/site/pack/deps/start/mini.nvim"; if vim.fn.empty(vim.fn.glob(mini_path)) > 0 then vim.fn.system({"git", "clone", "--depth", "1", "https://github.com/echasnovski/mini.nvim", mini_path}) end; vim.cmd("packadd mini.nvim"); local add = require("mini.deps").add; add({ source = "nvim-lua/plenary.nvim" }); add({ source = "ThePrimeagen/harpoon", checkout = "harpoon2" }); local harpoon = require("harpoon"); harpoon:setup(); local function safe_format() local ft=vim.bo.filetype local commands={python={cmd={"ruff","format"},clean={"ruff","clean"}},go={cmd={"gofmt","-w","%"},clean={"goimports","-w","%"}}} local fmt=commands[ft] if not fmt then vim.notify("No formatter for "..ft,vim.log.levels.WARN) return end local function run_command(command,on_success) if vim.fn.executable(command[1])~=1 then vim.notify("Missing executable: "..command[1],vim.log.levels.ERROR) return end vim.fn.jobstart(command,{stdout_buffered=true,stderr_buffered=true,on_exit=function(_,code) vim.schedule(function() if code==0 then if on_success then on_success() end else vim.notify(table.concat(command," ").." failed",vim.log.levels.ERROR) end end) end}) end run_command(fmt.cmd,function() if fmt.clean then run_command(fmt.clean,function() vim.cmd("edit!") vim.notify("Formatted and cleaned "..ft..", buffer reloaded",vim.log.levels.INFO) end) else vim.cmd("edit!") vim.notify("Formatted "..ft..", buffer reloaded",vim.log.levels.INFO) end end) end

for _, m in ipairs({
    { "n", "<leader>w", function() MiniTrailspace.trim() MiniTrailspace.trim_last_lines() vim.cmd.write() end, "+1 Trim & Save" }, { "n", "<leader>q", ":exit<CR>", "Quit" }, { "n", "<leader>wq", function() MiniTrailspace.trim() MiniTrailspace.trim_last_lines() vim.cmd("xa") end, "Save & Quit" },
    { "n", "<leader>a", function() harpoon:list():add() end, "Harpoon Add" },
    { "n", "<C-e>", function() require("harpoon").ui:toggle_quick_menu(require("harpoon"):list()) end, "Harpoon Menu" },
    { "n", "<C-h>", function() harpoon:list():select(1) end, "Harpoon 1" },
    { "n", "<C-t>", function() harpoon:list():select(2) end, "Harpoon 2" },
    { "n", "<C-n>", function() harpoon:list():select(3) end, "Harpoon 3" },
    { "n", "<C-s>", function() harpoon:list():select(4) end, "Harpoon 4" },
    { "n", "<leader>hx", function() require("harpoon"):list():clear() end, "Harpoon Clear" },
    { "n", "<leader>f", ":Pick files<CR>", "+4 Pick: Files" },
    { "n", "<leader>fg", ":Pick grep_live<CR>", "Pick: Grep" },
    { "n", "<leader>fw", function() MiniPick.builtin.grep({ pattern = vim.fn.expand("<cword>") }) end, "Pick: Word" },
    { "n", "<leader>fb", ":Pick buffers<CR>", "Pick: Buffers" },
    { "n", "<leader>fc", ":Pick colorschemes<CR>", "Pick: Colorschemes"},
    { "n", "<leader>h", ":Pick help<CR>", "+1 Pick: Help" },
    { "n", "<leader>e", ":Oil<CR>", "+1 Oil: Explorer" },
    { "n", "<leader>ef", function() MiniFiles.open() end, "MiniFiles" },
    { "n", "<leader>wz", function() MiniMisc.zoom() end, "Zoom Window" }, { { "n", "x", "o" }, "<leader>j", function() MiniJump2d.start() end, "MiniJump2d: Start jump" },
    { "n", "<leader>lf", vim.lsp.buf.format, "LSP: Format" }, { "n", "<leader>l", function() end, "+1 Lsp" },
    { "n", "<leader>cm", ":Mason<CR>", "Open Mason" }, { "n", "<leader>c", function() end, "+2 Code Tools" },
    { "n", "<leader>b", ":buffers<CR>", "+4 Buffers" },
    { "n", "<leader>bn", ":bn<CR>", "Next Buffer" },
    { "n", "<leader>bp", ":bp<CR>", "Prev Buffer" },
    { "n", "<leader>bd", ":bd<CR>", "Delete Buffer" },
    { "n", "<leader>bf", ":bd!<CR>", "Force Delete Buffer" },
    { "n", "<leader>d", function() vim.diagnostic.open_float(nil, { scope = "l" }) end, "+1 Show Diagnostic" }, { "n", "<leader>da", function() vim.diagnostic.setqflist({ open = true, title = "Diagnostics"}) end, "Show All Diagnostics"},
    { { "n", "v" }, "d", '"_d', "Delete (no yank)" },
    { { "n", "v" }, "c", '"_c', "Change (no yank)" },
    { "n", "x", '"_x', "Cut (no yank)" },
    { "n", "<C-p>", function() vim.cmd('botright split term://powershell') end, "Open PowerShell" }, { "n", "<leader>ca", safe_format, "Code Actions" },
    { "n", "<leader>gg", function() if vim.fn.executable("lazygit") == 1 then vim.cmd("botright split term://lazygit") else vim.notify("lazygit not found", vim.log.levels.WARN)end end, "Lazygit" }, { "n", "<leader>g", function() end, "+1 Git Integration" },
}) do vim.keymap.set(m[1], m[2], m[3], { desc = m[4] }) end

vim.pack.add({
    { src = "https://github.com/neovim/nvim-lspconfig" },
    { src = "https://github.com/mason-org/mason.nvim" },
    { src = "https://github.com/stevearc/oil.nvim" },
    { src = "https://github.com/echasnovski/mini.nvim" },
    { src = "https://github.com/vague2k/vague.nvim" },
    { src = "https://github.com/rose-pine/neovim" },
    { src = "https://github.com/folke/tokyonight.nvim" },
})

require("mason").setup()
require("oil").setup({ keymaps = { q = "actions.close", l = "actions.select", h = "actions.parent", ["<leader>r"] = "actions.refresh" }, view_options = { show_hidden = true } })
for _,m in ipairs({"ai","bracketed","bufremove","comment","completion","diff","extra","git","icons","jump","jump2d","misc","move","pairs","pick","snippets","tabline","trailspace"}) do require("mini."..m).setup() end
MiniIcons.tweak_lsp_kind(); require("mini.notify").setup({ lsp_progress = { enable = true, duration_last = 500 }, window = { config = { border = "solid" }, max_width_share = 0.6 } }) ; require("mini.indentscope").setup({ draw = { animation = require("mini.indentscope").gen_animation.quadratic({ easing = 'in-out', duration = 20 }) }, symbol = "│", options = { try_as_border = true } }); require("mini.hipatterns").setup({ highlighters = { fixme = { pattern = "%f[%w]()FIXME()%f[%W]", group = "MiniHipatternsFixme" }, hack = { pattern = "%f[%w]()HACK()%f[%W]", group = "MiniHipatternsHack" }, todo = { pattern = "%f[%w]()TODO()%f[%W]", group = "MiniHipatternsTodo" }, note = { pattern = "%f[%w]()NOTE()%f[%W]", group = "MiniHipatternsNote" }, hex_color = require("mini.hipatterns").gen_highlighter.hex_color() } }); require("mini.files").setup({ windows = { preview = true, width_focus = 50, width_nofocus = 15, width_preview = 25, }, }); local animate = require("mini.animate"); local cursor_anim_enabled = false; local function set_cursor_animation(e) local t = { cursor = { enable = e, timing = animate.gen_timing.quadratic({ easing = "out", duration = 75, unit = "total" }), path = function(d) local p = animate.gen_path.line({ predicate = function() return true end, max_step = 300 })(d) local l = 1; local r = {} for i = 1, #p do for o = 0, l - 1 do local c = p[i][1] - o; local col = p[i][2]; if c >= 0 then table.insert(r, { c, col }) end end end return r end } }; animate.setup(t); cursor_anim_enabled = e end; set_cursor_animation(false); local mode_map = {n="NORMAL", no="OP PENDING", nov="OP PENDING (VISUAL)", noV="OP PENDING (V-LINE)", ["no\22"]="OP PENDING (V-BLOCK)", niI="NORMAL (INSERT)", niR="NORMAL (REPLACE)", niV="NORMAL (V-REPLACE)", nt="TERMINAL", v="VISUAL", V="V-LINE", ["\22"]="V-BLOCK", s="SELECT", S="S-LINE", ["\19"]="S-BLOCK", i="INSERT", ic="INSERT (COMPL)", ix="INSERT (COMPL)", R="REPLACE", Rc="REPLACE (COMPL)", Rv="V-REPLACE", Rx="REPLACE (COMPL)", c="COMMAND", cv="VIM EX", ce="EX", r="PROMPT", rm="MORE", ["r?"]="CONFIRM", ["!"]="SHELL", t="TERMINAL"}; require("mini.statusline").setup({ use_icons = true, content = { active = function() local mode_code = vim.fn.mode() local mode_name = mode_map[mode_code] or mode_code local mode_hl_map = { n="MiniStatuslineModeNormal", no="MiniStatuslineModeNormal", nov="MiniStatuslineModeVisual", noV="MiniStatuslineModeVisual", ["no\22"]="MiniStatuslineModeVisual", niI="MiniStatuslineModeInsert", niR="MiniStatuslineModeReplace", niV="MiniStatuslineModeReplace", nt="MiniStatuslineModeTerminal", v="MiniStatuslineModeVisual", V="MiniStatuslineModeVisual", ["\22"]="MiniStatuslineModeVisual", s="MiniStatuslineModeSelect", S="MiniStatuslineModeSelect", ["\19"]="MiniStatuslineModeSelect", i="MiniStatuslineModeInsert", ic="MiniStatuslineModeInsert", ix="MiniStatuslineModeInsert", R="MiniStatuslineModeReplace", Rc="MiniStatuslineModeReplace", Rv="MiniStatuslineModeReplace", Rx="MiniStatuslineModeReplace", c="MiniStatuslineModeCommand", cv="MiniStatuslineModeCommand", ce="MiniStatuslineModeCommand", r="MiniStatuslineModePrompt", rm="MiniStatuslineModePrompt", ["r?"]="MiniStatuslineModePrompt", ["!"]="MiniStatuslineModeShell", t="MiniStatuslineModeTerminal" } local mode_hl = mode_hl_map[mode_code] or "MiniStatuslineModeNormal" local mode_section = "%#" .. mode_hl .. "# " .. mode_name .. " " local file = "%#MiniStatuslineFilename# " .. (vim.fn.expand("%:t") ~= "" and vim.fn.expand("%:t") or "[No Name]") .. " " local branch = "" if vim.b.gitsigns_status_dict and vim.b.gitsigns_status_dict.head then branch = "%#MiniStatuslineGit# " .. vim.b.gitsigns_status_dict.head .. " " end local errors=#vim.diagnostic.get(0,{severity=vim.diagnostic.severity.ERROR}) local warns=#vim.diagnostic.get(0,{severity=vim.diagnostic.severity.WARN}) local infos=#vim.diagnostic.get(0,{severity=vim.diagnostic.severity.INFO}) local hints=#vim.diagnostic.get(0,{severity=vim.diagnostic.severity.HINT}) local diagnostics="" if errors>0 then diagnostics=diagnostics.."%#MiniStatuslineError# "..errors.." " end if warns>0 then diagnostics=diagnostics.."%#MiniStatuslineWarn# "..warns.." " end if infos>0 then diagnostics=diagnostics.."%#MiniStatuslineInfo# "..infos.." " end if hints>0 then diagnostics=diagnostics.."%#MiniStatuslineHint# "..hints.." " end local ft=vim.bo.filetype~="" and vim.bo.filetype or "-" local enc=(vim.bo.fenc~="" and vim.bo.fenc) or vim.o.enc local ff=vim.bo.fileformat local file_info="%#MiniStatuslineFileinfo# "..ft.." "..enc.." "..ff.." " local pos="%#MiniStatuslinePosition# "..vim.fn.line(".")..":"..vim.fn.col(".").." " local pct="%#MiniStatuslinePercent# "..math.floor((vim.fn.line(".")/math.max(vim.fn.line("$"),1))*100).."%% " local left=table.concat({mode_section,branch,file,diagnostics}) local right=table.concat({file_info,pct,pos}) return left.."%="..right end, inactive=function() local file="%#MiniStatuslineFilename# "..(vim.fn.expand("%:t")~="" and vim.fn.expand("%:t") or "[No Name]").." " local pos="%#MiniStatuslinePosition# "..vim.fn.line(".")..":"..vim.fn.col(".").." " return file.."%="..pos end } })

vim.notify = require("mini.notify").make_notify()

local lspconfig = require("lspconfig"); vim.lsp.enable({ "lua_ls", "pyright", "ruff", "gopls", "rust_analyzer" }); vim.lsp.config("lua_ls", { settings = { Lua = { workspace = { library = vim.api.nvim_get_runtime_file("", true) } } } }); vim.lsp.config("gopls", { settings = { gopls = { analyses = { unusedparams = true, shadow = true }, staticcheck = true } } }); local rust_capabilities = vim.lsp.protocol.make_client_capabilities(); rust_capabilities.textDocument.completion.completionItem.snippetSupport = true; rust_capabilities.textDocument.completion.completionItem.resolveSupport = { properties = { "documentation", "detail", "additionalTextEdits" } }; lspconfig.rust_analyzer.setup({ capabilities = rust_capabilities, settings = { ["rust-analyzer"] = { cargo = { allFeatures = true }, checkOnSave = true, procMacro = { enable = true }, lens = { enable = true } } } }); vim.api.nvim_create_autocmd("LspAttach", { callback = function(ev) local client = vim.lsp.get_client_by_id(ev.data.client_id); if client then vim.api.nvim_buf_set_option(ev.buf, "omnifunc", "v:lua.vim.lsp.omnifunc"); if client:supports_method("textDocument/completion") then vim.lsp.completion.enable(true, client.id, ev.buf, { autotrigger = true }) end end end }); vim.api.nvim_set_keymap('i', 'jk', '<Esc>', { noremap = true, silent = true }); vim.diagnostic.config({ virtual_text = { prefix = "■", spacing = 4, hl_mode = "combine", format = function(d) return string.format("%s [%s]", d.message, d.source or d.code or "") end }, signs = true, underline = true, update_in_insert = false, severity_sort = true, float = { border = "solid", header = "Diagnostic(s):", prefix = "● ", source = "always", focusable = true } }); vim.api.nvim_create_autocmd("BufEnter", { pattern = "*.rs", callback = function() local ok, _ = pcall(vim.lsp.buf.inlay_hint, 0, true) if not ok then end end })

require("vague").setup({ transparency = true }); require("rose-pine").setup({ variant = "auto", dark_variant = "main", dim_inactive_windows = true, extend_background_behind_borders = true, styles = { bold = true, italic = true, transparency = false }, groups = { border = "highlight_med", background = "base", panel = "surface", comment = "muted", link = "iris", punctuation = "subtle", error = "love", hint = "iris", info = "foam", warn = "gold", git_add = "foam", git_change = "rose", git_delete = "love", git_dirty = "rose", git_ignore = "muted", git_merge = "iris", git_rename = "pine", git_stage = "iris", git_text = "rose", head = "iris", hunk = "rose" } })

local transparency_enabled, current_scheme, idx = false, nil, 2; local schemes = {  "vague", "rose-pine-moon",  "tokyonight-night", "retrobox",  "rose-pine-main" }; local apply_transparency = function() if transparency_enabled then for _, group in ipairs({ "Normal", "NormalFloat", "SignColumn", "VertSplit", "StatusLine", "StatusLineNC", "TabLine", "TabLineSel", "TabLineFill", "Pmenu", "PmenuSel", "PmenuSbar", "PmenuThumb", "CursorLine", "LineNr", "CursorLineNr", "MsgArea", "Folded", "FoldColumn" }) do vim.api.nvim_set_hl(0, group, { bg = "NONE" }) end end end; local set_colorscheme = function(name, notify) if not pcall(vim.cmd.colorscheme, name) then vim.notify("Colorscheme " .. name .. " not found", vim.log.levels.ERROR) return end if notify and name ~= current_scheme then vim.notify("Switched Colorscheme: " .. name, vim.log.levels.INFO) end current_scheme = name apply_transparency() end

vim.keymap.set("n", "<leader>t", function() idx = (idx % #schemes) + 1; set_colorscheme(schemes[idx], true) end, { desc = "UI: Cycle Colorschemes" }); vim.keymap.set("n", "<leader>tt", function() transparency_enabled = not transparency_enabled; set_colorscheme(current_scheme, false); vim.notify("Transparency: " .. (transparency_enabled and "Enabled" or "Disabled"), vim.log.levels.INFO) end, { desc = "Toggle Transparency" }); vim.keymap.set("n", "<leader>ta", function() set_cursor_animation(not cursor_anim_enabled); vim.notify("Cursor Animation " .. (cursor_anim_enabled and "Enabled" or "Disabled"), vim.log.levels.INFO) end, { desc = "Toggle cursor animation" })

set_colorscheme(schemes[idx], false)
