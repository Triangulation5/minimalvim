if vim.loader then vim.loader.enable() end; vim.g.mapleader, vim.g.loaded_netrw, vim.g.loaded_netrwPlugin = " ", 1, 1

local opt = vim.opt
for k,v in pairs({number=true,relativenumber=true,numberwidth=4,signcolumn="yes",tabstop=4,softtabstop=4,shiftwidth=4,expandtab=true,smartindent=true,breakindent=true,list=true,listchars={tab="  ",trail="·",extends="›",precedes="‹",nbsp="␣"},smartcase=true,hlsearch=false,incsearch=true,background="dark",guicursor="a:block",updatetime=50,timeoutlen=150,scrolloff=8,sidescrolloff=8,winborder="double",clipboard="unnamedplus",completeopt={"menuone","noselect"},conceallevel=0,pumheight=10,pumblend=15,winblend=25,swapfile=false,shada="",ruler=false,title=true,titlelen=0}) do vim.opt[k]=v end
vim.opt.fillchars:append({eob=" ",stl=" ",horiz=" ",horizup=" ",horizdown=" ",vertleft=" ",vertright=" ",verthoriz=" "}); vim.opt.shortmess:append("c")

for _,m in ipairs({{"n","<leader>w",function()MiniTrailspace.trim();MiniTrailspace.trim_last_lines();vim.cmd.write()end,"Trim + save"},{"n","<leader>q",":exit<CR>","Quit"},{"n","<leader>a",function()require("harpoon"):list():add()end,"Harpoon add"},{"n","<C-e>",function()require("harpoon").ui:toggle_quick_menu(require("harpoon"):list())end,"Harpoon menu"},{"n","<C-h>",function()require("harpoon"):list():select(1)end,"Harpoon 1"},{"n","<C-t>",function()require("harpoon"):list():select(2)end,"Harpoon 2"},{"n","<C-n>",function()require("harpoon"):list():select(3)end,"Harpoon 3"},{"n","<C-s>",function()require("harpoon"):list():select(4)end,"Harpoon 4"},{"n","<leader>hx",function()require("harpoon"):list():clear()end,"Harpoon clear"},{"n","<leader>ff",":Pick files<CR>","Pick: files"},{"n","<leader>fg",":Pick grep_live<CR>","Pick: grep"},{"n","<leader>fw",function()MiniPick.builtin.grep({pattern=vim.fn.expand("<cword>")})end,"Pick: word"},{"n","<leader>fb",":Pick buffers<CR>","Pick: buffers"},{"n","<leader>fr",":Pick oldfiles<CR>","Pick: recent"},{"n","<leader>h",":Pick help<CR>","Pick: help"},{"n","<leader>e",":Oil<CR>","Oil: explorer"},{"n","<leader>ef",function()MiniFiles.open()end,"MiniFiles"},{"n","<leader>wz",function()MiniMisc.zoom()end,"Zoom window"},{"n","<leader>lf",vim.lsp.buf.format,"LSP: format"},{"n","<leader>cm",":Mason<CR>","Open Mason"},{"n","<leader>b",":buffers<CR>","List buffers"},{"n","<leader>bn",":bnext<CR>","Next buffer"},{"n","<leader>bp",":bprev<CR>","Prev buffer"},{"n","<leader>bd",":bdelete<CR>","Delete buffer"},{"n","<leader>bm",":bmodified<CR>","Modified buffers"},{"n","<leader>d",function()vim.diagnostic.open_float(nil,{scope="buffer"})end,"Show all diagnostics"},{ {"n","v"},"d","\"_d","Delete (no yank)"},{ {"n","v"},"c","\"_c","Change (no yank)"},{"n","x","\"_x","Cut (no yank)"},{"n","<C-p>",function()vim.cmd('botright split term://powershell')end,"Open PowerShell"},{"n","<leader>ca",function()local ft,cmds=vim.bo.filetype,{python="ruff format && ruff clean",go="gofmt -w % && goimports -w %"};local cmd=cmds[ft] if not cmd then return vim.notify("No formatter for "..ft,vim.log.levels.WARN) end vim.fn.jobstart(cmd,{on_exit=function()vim.schedule(function()vim.cmd("edit!") vim.notify("Formatted and cleaned "..ft..", buffer reloaded")end)end})end,"Code Action"},{"n","<leader>gg",function()if vim.fn.executable("lazygit")==1 then vim.cmd("botright split term://lazygit") else vim.notify("lazygit not found",vim.log.levels.WARN)end end,"Lazygit"} }) do vim.keymap.set(m[1],m[2],m[3],{desc=m[4]}) end

vim.pack.add({{src="https://github.com/nvim-lua/plenary.nvim"},{src="https://github.com/neovim/nvim-lspconfig"},{src="https://github.com/mason-org/mason.nvim"},{src="https://github.com/stevearc/oil.nvim"},{src="https://github.com/ThePrimeagen/harpoon",checkout="harpoon2"},{src="https://github.com/echasnovski/mini.nvim"},{src="https://github.com/vague2k/vague.nvim"},{src="https://github.com/ellisonleao/gruvbox.nvim"},{src="https://github.com/rose-pine/neovim"},{src="https://github.com/folke/tokyonight.nvim"}})

require("mason").setup()
require("oil").setup({ keymaps = { q = "actions.close", l = "actions.select", h = "actions.parent", ["<leader>r"] = "actions.refresh" }, view_options = { show_hidden = true } })
require("harpoon").setup()
for _,m in ipairs({"ai","animate","completion","diff","extra","files","git","icons","jump","misc","move","pairs","pick","snippets","tabline","statusline","trailspace"}) do require("mini."..m).setup() end
require("mini.notify").setup({ lsp_progress = { enable = true, duration_last = 1000 }, window = { config = { border = "rounded" }, max_width_share = 0.6 } })
require("mini.indentscope").setup({ draw = { animation = require("mini.indentscope").gen_animation.none() }, symbol = "│", options = { try_as_border = true } })

vim.notify = require("mini.notify").make_notify()

vim.lsp.enable({ "lua_ls", "pylsp", "pyright", "ruff", "gopls" })
vim.lsp.config("lua_ls", { settings = { Lua = { workspace = { library = vim.api.nvim_get_runtime_file("", true) } } } })
vim.lsp.config("gopls", { settings = { gopls = { analyses = { unusedparams = true, shadow = true, }, staticcheck = true, }, }, })
vim.api.nvim_create_autocmd("LspAttach", { callback = function(ev) local client = vim.lsp.get_client_by_id(ev.data.client_id) if client and client:supports_method("textDocument/completion") then vim.lsp.completion.enable(true, client.id, ev.buf, { autotrigger = true }) end end,
})

require("vague").setup({ transparency = true })
require("gruvbox").setup({ terminal_colors = true, transparent_mode = false, contrast = "hard" })
require("rose-pine").setup({ variant = "auto", dark_variant = "main", dim_inactive_windows = true, extend_background_behind_borders = true, styles = { bold = true, italic = true, transparency = false }, groups = { border = "highlight_med", background = "base", panel = "surface", comment = "muted", link = "iris", punctuation = "subtle", error = "love", hint = "iris", info = "foam", warn = "gold", git_add = "foam", git_change = "rose", git_delete = "love", git_dirty = "rose", git_ignore = "muted", git_merge = "iris", git_rename = "pine", git_stage = "iris", git_text = "rose", head = "iris", hunk = "rose" } })
local function set_colorscheme(name) local ok = pcall(vim.cmd.colorscheme, name) if not ok then vim.notify("Colorscheme " .. name .. " not found", vim.log.levels.ERROR) return end if name == "gruvbox" then vim.api.nvim_set_hl(0, "SignColumn", { bg = "#1d2021" }) elseif name == "vague" then vim.api.nvim_set_hl(0, "StatusLine", { bg = "NONE" }) end end
local schemes={"gruvbox","vague","retrobox","rose-pine-main","rose-pine-moon"} local idx=0 vim.keymap.set("n","<leader>t",function() idx=(idx%#schemes)+1; local ok=pcall(vim.cmd.colorscheme,schemes[idx]) if not ok then vim.notify("Colorscheme "..schemes[idx].." not found",vim.log.levels.ERROR) end end,{desc="UI: Cycle colorschemes"})
set_colorscheme("rose-pine-moon")
